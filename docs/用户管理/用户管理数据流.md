# 用户管理数据流设计

## 概述

本文档详细说明 N-Admin 用户管理模块的数据流向、API 调用链路、状态更新机制和错误处理流程。

## 整体数据流架构

```mermaid
graph TB
    subgraph "前端层"
        A[用户操作] --> B[事件处理函数]
        B --> C[useUserManagement Hook]
    end

    subgraph "API层"
        C --> D[fetchUsers API]
        C --> E[createUser API]
        C --> F[updateUser API]
        C --> G[deleteUser API]
        C --> H[batchOperateUsers API]
    end

    subgraph "服务层"
        D --> I[JWT验证]
        E --> I
        F --> I
        G --> I
        H --> I

        I --> J[权限检查]
        J --> K[数据验证]
    end

    subgraph "数据层"
        K --> L[Drizzle ORM]
        L --> M[PostgreSQL]
        M --> L
        L --> K
    end

    subgraph "日志层"
        K --> N[Logger记录]
        I --> N
    end

    N --> O[system_logs表]

    style A fill:#e1f5ff
    style C fill:#fff4e6
    style I fill:#ffe6e6
    style L fill:#e6f7ff
    style N fill:#f0e6ff
```

## 用户查询数据流

### 时序图

```mermaid
sequenceDiagram
    participant U as 用户
    participant P as 页面组件
    participant H as useUserManagement Hook
    participant A as API /users
    participant D as 数据库
    participant L as Logger

    U->>P: 输入搜索关键词
    P->>H: updateFilters({ search: keyword })
    H->>H: 触发 fetchUsers
    H->>A: GET /api/users?search=keyword
    A->>A: JWT验证
    A->>A: 构建查询条件
    A->>D: SELECT ... WHERE ... LIKE
    D-->>A: 返回用户数据
    A->>L: 记录查询日志
    A-->>H: { users, pagination }
    H->>H: 更新状态
    H-->>P: 重新渲染
    P-->>U: 显示搜索结果
```

### 查询条件构建流程

```mermaid
graph TD
    A[开始查询] --> B{是否认证?}
    B -->|否| C[返回401错误]
    B -->|是| D[获取基础参数]
    D --> E[page, limit, search, status]
    E --> F[构建基础条件]
    F --> G[isDeleted = false]
    G --> H{有搜索关键词?}
    H -->|是| I[添加LIKE条件]
    H -->|否| J{有状态筛选?}
    I --> J
    J -->|是| K[添加status条件]
    J -->|否| L[添加排序条件]
    K --> L
    L --> M[执行SQL查询]
    M --> N[格式化数据]
    N --> O[计算分页]
    O --> P[返回响应]

    style C fill:#ffcccc
    style M fill:#e6f7ff
```

### 查询条件代码实现

```typescript
// 1. 基础条件
const conditions = [eq(users.isDeleted, false)];

// 2. 搜索条件（支持多字段模糊搜索）
if (search) {
  conditions.push(
    sql`(${users.username} ILIKE ${'%' + search + '%'} OR
         ${users.email} ILIKE ${'%' + search + '%'} OR
         ${users.realName} ILIKE ${'%' + search + '%'} OR
         ${users.phone} ILIKE ${'%' + search + '%'})`
  );
}

// 3. 状态筛选
if (status && status !== 'all') {
  conditions.push(eq(users.status, status));
}

// 4. 租户隔离（非超级管理员）
if (!currentUser?.isSuperAdmin) {
  conditions.push(eq(users.tenantId, currentUser.tenantId));
}

// 5. 排序
const orderByClause = sortOrder === 'desc'
  ? desc(users[sortBy])
  : asc(users[sortBy]);

// 6. 执行查询
const users = await db
  .select()
  .from(users)
  .where(and(...conditions))
  .limit(limit)
  .offset((page - 1) * limit)
  .orderBy(orderByClause);
```

## 用户创建数据流

### 时序图

```mermaid
sequenceDiagram
    participant U as 用户
    participant P as UserDialog
    participant H as useUserManagement Hook
    participant A as API POST /users
    participant V as Validator
    participant D as 数据库
    participant L as Logger

    U->>P: 填写用户表单
    P->>P: 表单验证
    P->>H: createUser(formData)
    H->>A: POST /api/users
    A->>A: JWT验证
    A->>V: validateUserCreation()
    V-->>A: { isValid, errors }

    alt 验证失败
        A-->>H: 错误响应
        H-->>P: 显示错误信息
    else 验证成功
        A->>A: 检查用户名唯一性
        A->>A: 检查邮箱唯一性
        A->>A: 密码bcrypt加密
        A->>D: BEGIN TRANSACTION
        A->>D: INSERT INTO users
        A->>D: INSERT INTO user_organizations
        A->>D: COMMIT
        D-->>A: 新用户ID
        A->>L: 记录创建日志
        A-->>H: 成功响应
        H->>H: fetchUsers()
        H-->>P: 刷新列表
        P->>P: 关闭对话框
        P-->>U: 显示成功提示
    end
```

### 创建流程状态机

```mermaid
stateDiagram-v2
    [*] --> 验证输入
    验证输入 --> 验证失败: 输入不合法
    验证输入 --> 检查唯一性: 输入合法
    验证失败 --> [*]: 返回错误

    检查唯一性 --> 用户名已存在: 用户名重复
    检查唯一性 --> 邮箱已存在: 邮箱重复
    检查唯一性 --> 密码加密: 通过唯一性检查

    用户名已存在 --> [*]: 返回错误
    邮箱已存在 --> [*]: 返回错误

    密码加密 --> 开始事务
    开始事务 --> 创建用户记录
    创建用户记录 --> 创建组织关联
    创建组织关联 --> 提交事务
    提交事务 --> 记录日志
    记录日志 --> [*]: 返回成功

    开始事务 --> 回滚事务: 任何错误
    回滚事务 --> [*]: 返回错误
```

### 事务处理流程

```typescript
await db.transaction(async (tx) => {
  // 1. 创建用户记录
  const newUser = await tx.insert(users).values({
    username,
    email,
    password: hashedPassword,
    phone,
    realName,
    roleId,
    tenantId,
    status,
    avatar: '/avatars/default.jpg',
    createdBy: currentUser?.id,
    updatedBy: currentUser?.id
  }).returning({ id: users.id });

  // 2. 创建组织关联
  if (organizationIds && organizationIds.length > 0) {
    const orgRelations = organizationIds.map((orgId, index) => ({
      userId: newUser[0].id,
      organizationId: BigInt(orgId),
      position: '',
      isMain: index === 0 // 第一个组织为主组织
    }));

    await tx.insert(userOrganizations).values(orgRelations);
  }

  // 事务自动提交
});
```

## 用户更新数据流

### 时序图

```mermaid
sequenceDiagram
    participant U as 用户
    participant P as EditDialog
    participant H as useUserManagement Hook
    participant A as API PUT /users/:id
    participant D as 数据库
    participant L as Logger

    U->>P: 修改用户信息
    P->>H: updateUser(id, formData)
    H->>A: PUT /api/users/:id
    A->>A: JWT验证
    A->>A: 获取原始用户信息
    A->>A: 输入验证
    A->>A: 超级管理员检查

    alt 是超级管理员
        A-->>H: 403 Forbidden
        H-->>P: 显示错误
    else 验证通过
        A->>D: BEGIN TRANSACTION
        A->>A: 对比变更字段
        A->>D: UPDATE users SET ...
        alt 有组织变更
            A->>D: DELETE FROM user_organizations
            A->>D: INSERT INTO user_organizations
        end
        A->>D: COMMIT
        D-->>A: 更新成功
        A->>L: 记录变更详情
        A-->>H: 成功响应
        H->>H: fetchUsers()
        H-->>P: 刷新列表
        P-->>U: 显示成功提示
    end
```

### 变更追踪机制

```typescript
// 1. 获取原始数据
const originalUser = await db
  .select()
  .from(users)
  .where(eq(users.id, id))
  .limit(1);

// 2. 对比变更
const changedFields = {
  username: originalUser[0].username !== username
    ? { from: originalUser[0].username, to: username }
    : undefined,
  email: originalUser[0].email !== email
    ? { from: originalUser[0].email, to: email }
    : undefined,
  // ... 其他字段
};

// 3. 记录变更日志
await logger.info('更新用户', '用户信息更新成功', {
  targetUserId: id,
  targetUsername: originalUser[0].username,
  changedFields,
  operatorId: currentUser?.id,
  operatorName: currentUser?.username
});
```

## 用户删除数据流

### 时序图

```mermaid
sequenceDiagram
    participant U as 用户
    participant P as DeleteConfirm
    participant H as useUserManagement Hook
    participant A as API DELETE /users/:id
    participant D as 数据库
    participant L as Logger

    U->>P: 点击删除按钮
    P->>U: 显示确认对话框
    U->>P: 确认删除
    P->>H: deleteUser(id)
    H->>A: DELETE /api/users/:id
    A->>A: JWT验证
    A->>A: 获取目标用户信息
    A->>A: 超级管理员检查

    alt 是超级管理员
        A-->>H: 403 Forbidden
        H-->>P: 错误提示
    else 可以删除
        A->>D: UPDATE users SET<br/>isDeleted=true, deletedAt=NOW()
        D-->>A: 删除成功
        A->>L: 记录删除日志
        A-->>H: 成功响应
        H->>H: fetchUsers()
        H-->>P: 刷新列表
        P-->>U: 成功提示
    end
```

### 软删除实现

```typescript
// 不使用物理删除，使用标记删除
await db
  .update(users)
  .set({
    isDeleted: true,
    deletedAt: new Date(),
    updatedBy: currentUser?.id
  })
  .where(eq(users.id, id));

// 日志记录
await logger.warn('删除用户', '用户删除成功', {
  targetUserId: id,
  targetUsername: targetUser[0].username,
  targetEmail: targetUser[0].email,
  deletedAt: new Date().toISOString(),
  operatorId: currentUser?.id,
  operatorName: currentUser?.username
});
```

## 批量操作数据流

### 时序图

```mermaid
sequenceDiagram
    participant U as 用户
    participant P as BatchActions
    participant H as useUserManagement Hook
    participant A as API POST /users/batch
    participant D as 数据库
    participant L as Logger

    U->>P: 选择多个用户
    P->>H: toggleUserSelection(userId)
    H->>H: 更新selectedUsers数组
    P->>P: 显示浮动操作栏

    U->>P: 点击批量激活
    P->>H: batchOperateUsers('activate', selectedUsers)
    H->>A: POST /api/users/batch
    A->>A: JWT验证
    A->>A: 检查超级管理员保护

    alt 包含超级管理员
        A-->>H: 403 Forbidden
        H-->>P: 错误提示
    else 检查通过
        A->>D: UPDATE users SET status='active'<br/>WHERE id IN (...)
        D-->>A: 影响行数
        A->>L: 记录批量操作日志
        A-->>H: 成功响应
        H->>H: clearUserSelection()
        H->>H: fetchUsers()
        H-->>P: 刷新列表
        P-->>U: 成功提示
    end
```

### 批量操作流程

```mermaid
graph TD
    A[开始批量操作] --> B{操作类型}
    B -->|activate| C[批量激活]
    B -->|deactivate| D[批量禁用]
    B -->|delete| E[批量删除]
    B -->|assignRole| F[批量分配角色]

    C --> G[遍历用户ID]
    D --> G
    E --> H[检查超级管理员]
    F --> I[验证角色ID]

    G --> J{是否是超级管理员?}
    J -->|是| K[跳过此用户]
    J -->|否| L[添加到操作列表]

    H --> J
    I --> M[准备批量更新]
    L --> M

    M --> N[执行批量UPDATE]
    N --> O[记录操作日志]
    O --> P[返回操作结果]

    K --> Q[记录警告日志]
    Q --> P

    style K fill:#ffcccc
    style P fill:#ccffcc
```

## 状态管理流程

### React状态更新流程

```mermaid
graph TD
    A[用户操作] --> B[事件处理函数]
    B --> C[调用Hook方法]
    C --> D[更新内部状态]
    D --> E[触发API调用]
    E --> F[等待响应]
    F --> G{响应成功?}
    G -->|是| H[更新数据状态]
    G -->|否| I[更新错误状态]
    H --> J[触发重新渲染]
    I --> J
    J --> K[UI更新]

    style H fill:#ccffcc
    style I fill:#ffcccc
```

### useUserManagement Hook状态流

```typescript
interface UserManagementState {
  // 数据状态
  users: User[];                    // 用户列表
  roles: Role[];                    // 角色列表
  loading: boolean;                 // 加载状态
  error: string | null;             // 错误信息
  pagination: PaginationInfo;       // 分页信息
  statistics: UserStatistics;       // 统计数据

  // 选择状态
  selectedUsers: number[];          // 选中的用户ID

  // 操作方法
  fetchUsers: (filters: UserFilters) => Promise<void>;
  createUser: (data: UserFormData) => Promise<boolean>;
  updateUser: (id: number, data: UserFormData) => Promise<boolean>;
  deleteUser: (id: number) => Promise<boolean>;
  // ...
}

// 状态更新流程
const fetchUsers = async (filters: UserFilters) => {
  setLoading(true);
  setError(null);

  try {
    const response = await fetch('/api/users?' + buildQueryString(filters));
    const data = await response.json();

    if (data.success) {
      setUsers(data.data);
      setPagination(data.pagination);
    } else {
      setError(data.error);
    }
  } catch (error) {
    setError('获取用户列表失败');
  } finally {
    setLoading(false);
  }
};
```

## 错误处理流程

### 错误处理策略

```mermaid
graph TD
    A[API调用] --> B{响应状态}
    B -->|200| C[解析响应数据]
    B -->|400| D[参数错误]
    B -->|401| E[未认证]
    B -->|403| F[无权限]
    B -->|404| G[资源不存在]
    B -->|500| H[服务器错误]

    C --> I{success字段}
    I -->|true| J[返回data]
    I -->|false| K[提取error信息]

    D --> L[显示表单验证错误]
    E --> M[跳转登录页]
    F --> N[显示权限不足]
    G --> O[显示资源不存在]
    H --> P[显示系统错误]
    K --> Q[显示业务错误]

    L --> R[用户重试]
    N --> R
    O --> R
    P --> R
    Q --> R

    style J fill:#ccffcc
    style L fill:#ffffcc
    style N fill:#ffcccc
    style P fill:#ffcccc
```

### 错误处理代码示例

```typescript
// API层错误处理
export async function PUT(request: Request, { params }: { params: Promise<{ id: string }> }) {
  const currentUser = getCurrentUser(request);
  const logger = new Logger('用户管理', currentUser?.id);

  try {
    // ... 业务逻辑

  } catch (error) {
    // 记录错误日志
    await logger.error('更新用户', '更新用户失败：系统错误', {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      operatorId: currentUser?.id,
      operatorName: currentUser?.username
    });

    // 返回错误响应
    return errorResponse((error as Error)?.message || '更新用户失败');
  }
}

// 前端错误处理
const updateUser = async (id: number, data: UserFormData) => {
  try {
    const response = await fetch(`/api/users/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });

    const result = await response.json();

    if (!result.success) {
      // 显示错误消息
      toast.error(result.error || '操作失败');
      return false;
    }

    toast.success('操作成功');
    return true;

  } catch (error) {
    console.error('API调用失败:', error);
    toast.error('网络错误，请重试');
    return false;
  }
};
```

## 数据缓存策略

### 缓存层次

```mermaid
graph LR
    A[用户操作] --> B[浏览器缓存]
    B --> C[React状态]
    C --> D[API缓存]
    D --> E[数据库查询缓存]
    E --> F[PostgreSQL]

    style C fill:#e1f5ff
    style D fill:#fff4e6
    style E fill:#e6f7ff
```

### 缓存失效策略

```typescript
// 创建/更新/删除后刷新列表
const handleCreateUser = async (data: UserFormData) => {
  const success = await createUser(data);
  if (success) {
    // 清除缓存
    await fetchUsers(filters); // 重新获取最新数据
  }
};

// 筛选条件变化时刷新列表
useEffect(() => {
  fetchUsers(filters);
}, [filters, fetchUsers]);
```

## 性能优化

### 查询优化

```typescript
// 1. 只查询需要的字段
const users = await db
  .select({
    id: users.id,
    username: users.username,
    email: users.email,
    // 只选择必要字段
  })
  .from(users);

// 2. 使用索引
// users表索引：username, email, tenant_id, status, is_deleted

// 3. 分页查询
const users = await db
  .select()
  .from(users)
  .limit(limit)
  .offset((page - 1) * limit);

// 4. JOIN优化
const users = await db
  .select({
    user: users,
    role: roles
  })
  .from(users)
  .leftJoin(roles, eq(users.roleId, roles.id));
```

### 请求优化

```typescript
// 1. 防抖搜索
const debouncedSearch = useMemo(
  () => debounce((keyword: string) => {
    updateFilters({ search: keyword });
  }, 300),
  []
);

// 2. 并行请求
const [users, statistics] = await Promise.all([
  fetchUsers(filters),
  fetchStatistics()
]);

// 3. 请求取消
const abortController = new AbortController();
fetch('/api/users', {
  signal: abortController.signal
});
```

## 数据流总结

| 数据流类型 | 特点 | 优化策略 |
|-----------|------|----------|
| 查询流 | 只读操作 | 缓存、索引、分页 |
| 创建流 | 写入操作 | 事务、唯一性检查 |
| 更新流 | 修改操作 | 变更追踪、乐观锁 |
| 删除流 | 软删除 | 标记删除、审计日志 |
| 批量流 | 批量操作 | 事务批处理、进度反馈 |
| 状态流 | React状态 | 防抖、缓存更新 |
| 错误流 | 异常处理 | 统一错误处理、日志记录 |
